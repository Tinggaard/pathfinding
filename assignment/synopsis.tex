\documentclass[a4paper, 12pt]{article}
\usepackage[danish]{babel} % Language
\usepackage{minted} % Code inclusion
\usepackage{lastpage} % Pagenumbering
\usepackage{fancyhdr} % Custom header/footer
\usepackage{amsmath} % Align
\usepackage{changepage} % for the adjustwidth environment
\usepackage{multirow} % Multiple rows in tabular
\usepackage{enumitem} % space between items in list
\usepackage[page, titletoc]{appendix} % appendicies
\usepackage{wrapfig} % small figure
\usepackage[pdftitle={Programmering eksamen 2020},pdfauthor={Jens Tinggaard}, bookmarks=true]{hyperref} %References
\usepackage{cleveref} % referencing list
\usepackage[margin=1in]{geometry} %Margins
\usepackage{xcolor} % bg for minted
% \usepackage{attachfile} % Attach files in sources

% Biblografi
\usepackage{csquotes}
% \usepackage[style=numeric, style=alphabetic]{biblatex} %style=numeric
% \addbibresource{biblography.bib}
% \DeclareNameAlias{default}{family-given}

\emergencystretch=1em  % hbox not too wide


\pagestyle{fancy} % Set custom page layout
\fancyhf{}% to clear existing header/footer
% Set line on header and footer width
% \renewcommand{\headrulewidth}{2pt}
% \renewcommand{\footrulewidth}{1pt}


\addto\captionsdanish{\renewcommand\appendixname{Appendiks}} % appekdiks in toc
\renewcommand{\appendixpagename}{Appendiks} %appekdiks in page


\definecolor{bg}{rgb}{0.95,0.95,0.95} % Baggrund af kode.

\newcommand{\ny}
  {
  \vskip 1em
  }

% \attachfilesetup{ % Setup af attachfile pakken.
% author={Jens Tinggaard},
% color={1 0 0},
% icon={Paperclip}
% }

% Headers and footers
\lhead{Jens Tinggaard 3.E\\ Odense Tekniske Gymnasium}
\rhead{Vejleder: JCJE\\ 1. maj 2020}

% \lfoot{\rightmark} % Subsection
\lfoot{\rightmark} % SECTION
\rfoot{Side \thepage\ af \pageref{LastPage}}


% Navn på indholdsfortegnelse
\addto\captionsdanish{\renewcommand*\contentsname{Indholdsfortegnelse}}

% Basic info
\date{1. maj 2020}
\title{Pathfinding algoritmer}
\author{Jens Tinggaard}


\setlength{\parindent}{0em} % Identeringsstørrelse = 0
% Bruges med \par

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\thispagestyle{empty}
\maketitle

\vskip 10 em
{\center\Huge
\textbf{BILLEDE!!}\\
}

\newpage
\tableofcontents


\newpage
\section{Indledning}
\subsection{Målsætning}
\textit{Fra projektbeskrivelsen:}\\
Jeg vil gerne lave et program, der er i stand til at illustrere en pathfinding algoritme. Jeg vil gerne vise fordelen ved en pathfinding algoritme, dette kunne f.eks. gøres ved at sammenligne med en bruteforce algoritme. Umiddelbart vil det tage udgangspunkt i labyrinter, hvor jeg vil vise hvordan de forskellige algoritmer virker.
\subsection{Krav til programmet}
\begin{itemize}
  \item Implementering af en pathfinding algoritme
  \item Kunne løse en labyrint
  \item Sammenligning med andre metoder til at løse en labyrint
  \item Visuel repræsentation af løsningen
\end{itemize}
\subsection{Udviddelser}
\begin{itemize}
  \item Visualisering af hastighed vs. størrelse af labyrint for forskellige metoder
  \item Implementering af flere algoritmer (nogle af dem fra ovenstående liste)
\end{itemize}


\newpage
\section{Om pathfinding algoritmer}\label{subsec:about}
En pathfinding algoritme er en algoritme, som bruges til at finde vej over en graf. Der findes mange forskellige algoritmer, som alle har fordele og ulemper. Et par af de mest kendte er \textit{Dijkstra}, \textit{depthfirst}, \textit{breadthfirst} og \textit{A*}. Alle disse algoritmer har til fælles, at de beskriver en fremgangsmåde, til at finde den korteste vej mellem to noder på en graf.\ny
Pathfinding er brugt til alt muligt i dag, et klassisk eksempel er navigationstjenester som Google Maps. Når brugeren har indtastet en startposition og et mål, er det nu computerens opgave at finde den korteste vej derhen. Hvis man skal fra København til Rom er der måske en idé i, at optimere algoritmen, så den ikke starter med at kigge over St. Petersborg i Rusland. Alle disse overvejelser er vigtige at gøre sig, når man skal implementere en pathfinding algoritme, da forskellige algoritmer er stærke til hver deres ting.

\subsection{Grafer, noder og kanter}
Når man snakker om pathfinding algoritmer, vil termerne \textit{graf} og \textit{node} fremkomme. Begge disse typer er abstrakte og dækker over et større område inden for datalogien. En \textit{graf} er en struktur, som indeholder et endeligt antal hjørner, også kaldet \textit{noder}. Alle disse noder har ofte nogle bestemte attributter eller egenskaber, afhængig af hvilken type graf, der er tale om. Derudover er disse noder forbundet gennem hvad der kaldes \textit{kanter} en kant er i bund og grund en forbindelse mellem to noder, man sætter ofte en vægt på kanterne (medmindre alle kanter er vægtet ligeligt). Denne vægt bruges også i beskæfigelsen med grafer --- den er meget essentiel i forbindelse med pathfinding algoritmer.\footnote{\url{https://en.wikipedia.org/wiki/Graph_(abstract_data_type)}}\ny % billede af graf: https://commons.wikimedia.org/wiki/File:Sample_Graph_for_path_finding.png
Når man har med pathfinding algoritmer at gøre, vil alle noder have følgende attributter: \textbf{Naboer} alle noder er klar over hvilke noder de ligger op ad. \textbf{Via} alle noder er klar over hvilken node der forbinder dem til startnoden. \textbf{Pris} alle noder er klar over hvor langt de har til startnoden -- målt i samlet vægt af kanter op til denne -- inden denne pris er bestemt vil den være $\infty$. \textbf{Afstand til mål} når man bruger \textit{A*}, vil alle noder også være klar over deres afstand til målnoden, denne afstand er målt direkte, såkaldt fugleflugt, hvorimod at \textit{pris} er målt i den samlede pris fra de foregående noder + vægten af kanten fra den foregående node (\textit{via}) til den nuværende.

\subsection{Prioritetskø}\label{subsec:pq}
Algoritmerne \textit{Dijkstra} og \textit{A*} gør begge brug af en prioritetskø, kaldet en \textit{priority queue} på engelsk. En prioritetskø skal ses som en liste, som er dynamisk sorteret efter et parameter. I dette tilfælde er de sorteret efter en afstand, præcis hvilken afhænger af algoritmen --- mere herom senere.

\subsection{Algoritmer}
Det vises kort, hvordan nogle af de mest kendte algoritmer virker.
\subsubsection{Depthfirst}
Depthfirst er en algoritme, som -- som navnet antager -- scanner dybden først. Betragt Node $A$, som har forbindelse til Node $B$ og $C$, algoritmen tager fat i den første af disse Noder; $B$, som i dette tilfælde har forbindelse til $D$ og $E$, igen tager algoritmen den første af disse Noder og kigger videre ud i \textit{dybden}, til slutnoden er fundet.
\subsubsection{Breadthfirst}
Breadthfirst fungerer lige modsat af depthfirst, breadthfirst kigger nemlig i bredden først. Det vil altså sige at efter Noden $B$ er undersøgt, går algoritmen videre til $C$ i stedet for $D$ som depthfirst. Bagefter kigger algoritmen på $D$ og så $E$ og derefter de Noder som er forbundet til $C$.
\subsubsection{Dijkstra}
Dijkstra er en algoritme opkaldt efter dens skaber; \textit{Edsger W. Dijkstra}.\footnote{\url{https://en.wikipedia.org/wiki/Dijkstra's_algorithm}} Dijkstra tager fat i problemstillingen med vægting af sider på en graf, da disse spiller en rolle i udfaldet af algoritmen. Algoritmen er garenteret, til altid at finde den korteste vej fra start til slut. Algoritmen gør brug af en \nameref{subsec:pq}, som er sorteret efter afstand på alle de foregående kanter. Man tager altid fat i den lavest rangede Node i køen, hvilket vil sige at man får Noden, som er nået kortest uanset antal af foregående Noder. Man kan sige at Dijkstra er breadthfirst vægtet efter afstand i stedet for antal noder. Det betyder altså at når man har fundet en løsning, behøver man blot at markere den aktuelle kantlængde og tømme sin prioritetskø op til denne størrelse. Finder man en kortere vej, gemmes denne på samme vis. Man er på denne måde garanteret, at finde den korteste vej.
\subsubsection{A*}
A* er Dijkstra med en opgradering. Afstanden til målet regnes nemlig med, målt i fugleflugt. For hver Node gemmes den foregående Node, samt den samlede afstand stadig. Derudover gemmes afstanden til målet også (er alle Noder defineret i koordinater, kan Pythagoras bruges). Vægtningen af prioritetskøen foregår nu efter den samlede værdi af den tilbagelagte afstand, samt afstanden til målet. A* kræver altså lidt mere regnerkaft, men forbedrer samtidig målrettetheden af algoritmen, som forklaret i afsnittet "\nameref{subsec:about}".


\newpage
\section{Udarbejdning af projektet}
I forbindelse med projektet har jeg lavet et repository på GitHub (\url{https://git.io/JfINU}). Det medfølger naturligvis en README-fil, som også er vedlagt i Appendiks. Jeg vil kort gennemgå krav samt brug af programmet her, en uddybning kan findes i README-filen.

\subsection{Installation og brug}
Den letteste måde at bruge programmet på er:
\begin{minted}[fontsize=\footnotesize, bgcolor=bg]{bash}
$ git clone https://github.com/Tinggaard/pathfinding
$ cd pathfinding && virtualenv venv && . venv/bin/activate
$ pip install -e .
\end{minted}
Herefter vil det være muligt at køre hovedprogrammet (forudsat at brugeren stadig er i virtualenvironment), ved blot at kalde:
\begin{minted}[fontsize=\footnotesize, bgcolor=bg]{bash}
$ pathfinding [-h] (-i INPUT | -g width height) [-v] [-s] [-f] [-o OUTPUT]
              [-a {astar,dijkstra,breadthfirst,depthfirst,rightturn}]
\end{minted}
For at få en detaljeret beskrivelse af alle flagene, sættes flaget \texttt{-h} blot.\ny
Alternativt kan programmet installeres ved
\begin{minted}[fontsize=\footnotesize, bgcolor=bg]{bash}
$ pip install -r requirements.txt
\end{minted}
Herefter kaldes programmet som følger:
\begin{minted}[fontsize=\footnotesize, bgcolor=bg]{bash}
$ # cd pathfinding
$ ./main.py [-h] (-i INPUT | -g width height) [-v] [-s] [-f] [-o OUTPUT]
            [-a {astar,dijkstra,breadthfirst,depthfirst,rightturn}]
\end{minted}

\subsection{Eksempel}
Ønsker man at finde vej gennem \texttt{\href{https://github.com/Tinggaard/pathfinding/blob/master/mazes/perfect/1001.png}{mazes/perfect/1001.png}}, ved hjælp af breadthfirst algoritmen, samt at gemme outputtet igen som f.eks. \texttt{out/eksempel.png}, køres programmet som følger:
\begin{minted}[fontsize=\footnotesize, bgcolor=bg]{bash}
$ pathfinding -i mazes/perfect/1001.png -a breadthfirst -o out/eksempel.png
\end{minted}
% Indsæt billede!


\subsection{Idé no 1}
\subsection{Ændring}
\subsection{Idé no 2}


\newpage
\section{Konklusion}


% \newpage
% \setlength\bibitemsep{10pt}
% \printbibliography[
% heading=bibintoc, %Er med i indholdsfortegnelsen
% title={Litteratur} %Titel
% ]


\newpage
\begin{appendices}
\end{appendices}

\end{document}
